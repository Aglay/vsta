.TH MSG_RECEIVE 2
.SH NAME
msg_receive \- receive messages on a server port
.SH SYNOPSIS
.B #include <sys/msg.h>
.br
.B int msg_receive(port_t port, struct msg *msg);
.SH DESCRIPTION
.I msg_receive()
is used by a server to receive messages on a server's
port.  The received message may be either a regular
data message from one of the server's current clients,
or a system-generated notification of certain
exceptional events.  Messages with an
.I m_type
field below
.B M_RESVD
are guaranteed to be kernel-generated; they can not be spoofed.
.PP
Each message may contain one or more segments of data in a
scatter/gather format.  The field
.I m_nseg
indicates how many such segments were received; the actual
segments are described by the
.I m_seg[]
array of pointer/length structures.
.PP
The field
.I m_sender
indicates which client sent this message; in the case of an
.B M_CONNECT
message, it indicates the handle of the would-be connecter.  This
handle will be valid if the server
.I msg_accept()
's
the connection.
.PP
The fields
.I m_arg
and
.I m_arg1
are specified by the sender.  By convention,
.I m_arg
holds the number of bytes requested or sent in normal data
messages.
.PP
In the case of normal data messages, the request is completed
and a reply sent back by using
.I msg_reply().
.PP
Special messages (
.I m_op
less than
.B M_RESVD
)
are:
.RS
.B M_CONNECT
.br
A client has attempted connection with
.I msg_connect().
.I m_arg
holds the requested mode(s),
.I m_nseg
is always set to 1, and the segment holds an array
of
.I struct perm
elements, describing the abilities of the client.  Because
this is a kernel-generated message, the client may not spoof
it, and the permissions so described may be trusted by the
server.  This message must be completed by either a
.I msg_accept()
call (to accept the client) or a
.I msg_err()
call to reject the connection.
.PP
.bd 1
M_DISCONNECT
.br
This message indicates that a client has terminated, either
explicitly or due to an unhandled event.  The
.I m_sender
field identifies the client, who is no longer connected to
the server.
.PP
.B M_DUP
.br
This message is something of a misnomer.  A POSIX
.I dup()
causes two file descriptors to refer to the same connection; in contrast,
the
.B M_DUP
message causes the server to allocate a new distinct session, whose
state (i.e., file position, etc.) starts as a copy of the original
connection's, but is distinct.  It is caused by the
.I clone()
system call, as well as a part of the
.I fork()
operation.
.PP
.B M_ABORT
.br
When a pending operation is interrupted (i.e., a message
has been sent via
.I msg_send()
but a response has not yet been received, and the requesting
process receives an event), the kernel causes this message to
appear at the server.  It is expected that the server will
clear any state, and use a
.I msg_reply()
to indicate that it has reset the per-client state to a point
where the client may send a new request.
.PP
.B M_ISR
.br
This message is generated by the kernel for servers which have
registered for hardware interrupts.  The kernel clears the hardware
interrupt, and then queues this message for the server.  No
reply is needed for this message, which will never contain any
segments of data.  The
.I m_arg
field holds a count of the number of interrupts which have been
received since the message was queued, but before it was received.
.RE
