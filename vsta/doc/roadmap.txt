This is a quick roadmap of where things are and how to get things done.

0. Requirements
	I have a driver for the ST-506 "classic AT" hard disk interface.
This driver has also been verified with one and two disk IDE systems
(although two disk IDE is *begging* for trouble, in most people's
experience.)  The disk geometry can be obtained via (1) the controller's
"read parameter" command, (2) the NVRAM/BIOS stored disk parameters,
or (3) by hand-entering the disk parameters.  Detailed instructions
below.

	The console driver supports both MGA and CGA text screen
locations.  It is not currently auto-detect.  The keyboard driver
expects the AT scan codes.  The floppy driver only supports 1.2M and
1.44M (not 360K, nor 360K in a 1.2M drive.) I don't have 1.44M, so again
don't know if it works.  My system has 4M of RAM, and that seems to be
plenty.  Systems with up to 16 Meg have been booted.  There is code for
> 16 M, but it has not been tested and is certainly not complete.

	You will need the DJ Delorie GNU C compiler port.  The system
will compile and run with any version from 1.39 up--both GCC 1.X and
2.X based.  Nothing gets broken by the optimizer (that we've found!)
You can use your favorite "make"--we demand very little of it.  There
is a copy of "pdmake" sitting on our FTP server where you got these
files from.  It's ~28K, and does a fine job.

	If you want to recompile the boot loader in boot/, you will
need a DOS C compiler.  It uses large model, but doesn't do much of
anything fancy.  I happen to use Borland C and the turbo assembler
provided with it.  The program doesn't do much that needs changing,
so you should consider just using my .exe.  But the source is there,
if you want to change something.

1. Source organization

	All files are stored under RCS.  The RCS storage resides
inside the RCS/ subdir in each source directory.

	The source tree is organized along the lines of:

	os/		Kernel source
	os/make		Where objects are compiled into
	os/kern		Portable C source
	os/mach		i386 C, as well as assembly
	srv/		All portable servers (filesystems, etc.)
	srv/mach	i386/ISA servers (disk, keyboard, etc.)
	libc/		The C library
	lib/		Utility libraries
	bin/		Commands
	doc/		Documentation, such as it is

2. Building the kernel

	Go into the lib subdir.  Do a "make".
	Go into the ../os/make subdir.  Do a "make clean".  If this fails
because there's no makefile, don't worry.
	Build config: "gcc -o config config.c"
	Run the kernel config program:  "go32 config".  Now you should
have a makefile.
	Run the make: "make"
	Now you have a kernel.

3. Building the world

	Go to the root, and invoke the "mkclean" batch file.

	Now invoke the "mkall" batch file.  It will move around through
the source and build things in the right order.  GNU C is in its own
archive; send me a note if you want to build it and have problems.

	NOTE: some binaries (emacs, rc, gcc & friends) are in their
own distribution tar file.  They may not even be present in your source
tree.

4. Putting a boot filesystem in place

	Initial binaries are in the root directory in root.t, which
is a tar file.  You need to extract this in the root dir of your first
ST-506 DOS partition.  Sorry about using the bin/ dir, but VSTa
executables don't have an extension so it shouldn't interfere even if
you already have DOS executables there.

	Passwords are in /etc/passwd, and are in the clear.  Feel free
to edit this file using a DOS editor; VSTa tries to accomodate both
DOS \r\n and UNIX \n conventions for line-oriented data.  The format
is described in lib/passwd.c.  The group you belong to in the passwd
file causes you to get more abilities; see /etc/group.  Finally,
numeric format IDs are mapped to symbolic courtesy of /etc/ids.  You
can see how in lib/ids.c.

3. Booting the kernel

	Move to the "boot" subdir.

	Edit the file "boot.lst".  Each boot driver has a line here,
and the comments before each line should tell you how to fiddle
the line to reflect your hardware.  Currently, you need to edit
console driver to tell it whether you're CGA or MGA, and you need
to edit the line for the wd disk driver to tell it how to get
the parameters for your disk(s).

	Invoke the batch file "go".

	This will load the kernel in ..\os\make, and also load the
boot servers listed in boot.lst.  All the servers should have been
built by the "mkall", so there should be no problems.

4. Kernel debugger

	You have two options for kernel debugging.  As shipped,
the on-screen kernel debugger is selected.  If you want to have
the kernel debugger talk out the serial port, see os/mach/dbg*.c.

	Use the "pr" command to see the proc table, the "bt" command
to see a stack backtrace of the current process.  "dv" will dump virtual
addresses, and "dp" will dump physical.  You can look at the current
user process' address space by OR'ing in 0x80000000 to the user address.
"dv" will complain if you try to look at a non-existent address.  "di"
will disassemble at an address; symbols were put in during the kernel
build, so the output should be fairly comprehensible (if you know i386
assembly!)  The "=" will take expressions and print them in hex, decimal,
and symbolically.

	"pr <num>" will dump out a particular process with more detail.
"vas <addr>" will dump out a virtual address space struct; similarly for
"pset", "pview", "port", "ref" (portref).  "tf" will dump out the current
trapframe (from the last trip through trap()), or "tf <addr>" will
assume there's a trap frame at the given address, and dump it out
instead.

5. More?

	No doubt, but I can't think of what might help the most.
Stay in touch!
